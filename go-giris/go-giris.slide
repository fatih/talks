Go programlama dili
14 Mar 2015

Fatih Arslan
Software Engineer, Gopher, Coffee Geek
https://github.com/fatih
fatih@arslan.io
@ftharsln

* Giriş

* Go nedir?

- Ken Thompson, Rob Pike ve Robert Griesiemer tarafindan ilk adımları atıldı (2007)
- 10 Kasım 2009 yılında tanıtıldı, 28 Mart 2012'da Go 1.0 yayımlandı
- Genç ve yeni bir dil
- Açık Kaynak
- Basit ama güçlü
- C ailesine yakın dil tanımı
.image gophers.jpg

* Neden Go? (Sorunlar)

Büyük ölçekteki yazılımlari geliştirmenin zorluğu üzerine çıkmıştir. Nedir bu
sorunlar?

- Yavaş inşa sistemleri (build systems)

.image compiling.png

* Neden Go? (Sorunlar)

- Kontrol altına alınamayan bağımlılıklar

.image dependencies.jpg

* Neden Go? (Sorunlar)

- Insanlarin bir dilin özelliklerin belirli alt kümelerini kullanması

.image features.jpg

* Neden Go? (Sorunlar)

- Kod'u anlamak ve okumak zor
- Güncelleme maliyeti
- Makineler hızlı, ama yazılım geliştirme hala yavaş
- Eşzamanlı (concurrent) program geliştırme temelleri bir çok dilde yeterince gelişmemiş
- Google'deki yavaş ve hantal yazılım geliştirme'yi ortadan kaldırmak
- Büyük ölçekteki yazılımları kontrol altında tutmak

* Neden Go? (Çözumler)

- Büyük bir Go programini saniyeler içinde derleyebiliyorsunuz
- Sözdizimi (syntax) anlaşılır
- Temelleri basitlik üzerine kurulan bir düşünce yapısı
- Bağımlılık çözümu kolay ve basit (C tipi include dosyalari olmaksızın)
- Dahili eşzaman  yazılım temelleri (channels, goroutines, select)
- Static typed ama dynamic typed gibi hissediliyor
- Test, belgelendirme, bağımlılık yönetimi, vs.. ekosistemi


* Go'yi kimler kullaniyor?

- Google
- Apple
- Facebook
- Twitter
- Microsoft
- Amazon
- Github
- Ubuntu (Canonical)
- Dropbox
- ve daha fazlası: https://github.com/golang/go/wiki/GoUsers

* Paketler ve Isimlendirme

* Paketler

Her Go uygulaması paketlerden oluşur. 

Paketler ne içerir ? 
- Fonksiyon
- Türler
- Değişkenler
- Sabit türler (constants)

Bir paket bir dosya ve 10 satırdan oluşabileceği gibi, onlarca dosya ve
binlerce satır kod'dan da oluşabilir.

Başka paketleri kullanabilmek icin *import* ile dahil etmek gerekiyor.

* Main paketi

Main paketi özeldir. 

Bir Go uygulamasi main paketi ile ayağa kalkar ve çalışır. Diğer hiç bir paket
kendi başına calısmaz

.play code/main.go


* Isimlendirme

- Baş harfi *büyük* karakter ile başlayan tanımlamaları kullanabiliyorsunuz (public).  
- Bas harfi *küçük* karakter ile başlayan tanımlamaları dışarıdan erışemezsiniz (private).

Örnek: 

	var (
		name    = "example"
		region  = "asia"
		Version = "0.0.1"
	)

	func add(x, y int) int      { return x + y }
	func Multiply(x, y int) int { return x * y }

	type Color struct{}

	func (c *Color) Red(s string) {}
	func (c *Color) prepend()     {}



* Paketlerin kullanımı

Main dışındaki tüm paketler başkaları tarafından kullanılmalı

- package json

Standard library paketlerine doğrudan erişiyorsunuz

- import "fmt"
- import "encoding/json"

Dahil edilen paketin bir ismini değistirebilirsiniz

- import googlelog "google/base/go/log"

Uzaktaki bir sunucudan paket dahil edebilirsiniz

- import "github.com/streadway/amqp"
- import "golang.org/x/net/websocket"

* Paketlerin kullanımı (devam)

	package main

	import (
		"fmt"

		"github.com/fatih/color"
		log "github.com/koding/logging"
	)

	func main() {
		fmt.Println("example app")

		color.Red("Error message")

		l := log.NewLogger("app")
		l.Info("App started")
	}

* Go sözdizimi ve temel dil yapısı

* Türler

.play code/data/data.go /START OMIT/,/END OMIT/

* Değişkenler, çoklu sonuçlar, sıfır değerler, sabitler

Tanımlanmayan değişkenler, öntanımlı olarak o türün sıfır değerini alır.

	var a int
	fmt.Println(a) // a: 0

Fonksiyon girdilerini türe göre gruplayabilirsiniz.

	func foo(x, y, z int) int {}
	func bar(a int, b, c string) int {}

Birden fazla sonuç dönebiliriz 

	func foo() (int, bool) {}
	func bar() (string, string, float64) {}


* Değişkenler, çoklu sonuçlar, sıfır değerler, sabitler (örnek)

.play code/vars/vars.go /START OMIT/,/END OMIT/

* Hata yönetimi (errors)

Çoklu şonuç dönmek güzel, neden sonuçlardan biri *hata* türünde olmuyor?

Exception veya assert yok. C-style hata yönetimi

Hataları her zaman yönetmeniz gerekiyor, kaçıs yok.

C'de:

	file := os.Open("/path/file.txt")
	if file == -1 {
		return -1
	}

Go'da 

	file, err := os.Open("/path/file.txt")
	if err != nil {
		return 0, err
	}

	// file ile ilgili işlemler ...



* Akış kontrolleri

Basit akışlar:

- if, else
- for, break, continue
- switch, case, default, falltrhough
- return
- goto

Gelişmiş akışlar:

- range
- select
- go
- defer

* Defer

defer deyimi, kendisini çevreleyen fonksiyon dönene kadar fonksiyonun
çalışmasını erteler.

.play code/defer/defer.go

* Defer (devam)

.play -edit code/defer2/defer2.go /START OMIT/,/END OMIT/

* Defer (devam)

Çözum:

	func deadlock(a int) {
		mu.Lock()
		if 4 < a {
			mu.Unlock()
			return
		}
		mu.Unlock()
	}

Daha iyi:

	func deadlock(a int) {
		mu.Lock()
		defer mu.Unlock()

		if 4 < a {
			return
		}
	}

* Fonksiyonlar

First class functions

Fonksiyonlar da bir türdür

Anonymous fonksiyonlar

* Fonksiyonlar (devam)

Runnable bir örnek ekle

* Structs

Birden fazla veri ve türü organize etmeye yarar. 

	type MyInt int	

	type Vertex struct {
		X int
		Y MyInt
		Z bool
	}

Kullanım:

	func main() {
		v := Vertex{1, 2}
		v.X = 4
		fmt.Println(v.X)
	}

* Methods

Go'da Class yapısı bulunmaz. Ama metodlar ile bir *struct* türüne fonksiyonlar
tanımlayabilirsiniz.

.play code/methods/methods.go /START OMIT/,/END OMIT/

Metodlar Go'da çok önemli bir yere sahip.

* Methods (devam)

Metodları tanımladığınız her türe tanımlayabilirsiniz.

	package main

	import "fmt"

	type MyInt int

	func (m MyInt) Add(a int) int {
		return int(m) + a
	}

	func main() {
		var y MyInt = 4
		res := y.Add(5)

		fmt.Println(res) // res: 9
	}

* Interfaces (Arayüz)

Interface tanımlamasi bir veya birden fazla *metod* ile tanımlanır:

	type Adder interface {
		Add(int) int
	}

Interface de, tıpkı int, string, struct gibi bir türdür.

	var a Adder 

Bir tür interface ile tanımlanan metodları tanımlıyorsa o interface'i örtülü
(belirtmeden) gerçekleştirir

	p := Point{3, 4}
	m := MyInt(3)


* Interfaces (Örnek)

Point ve MyInt türleri *Add* metodunu tanımlıyor

	func (p Point) Add(a int) int {
		return p.X + p.Y + a
	}

	func (m MyInt) Add(a int) int {
		return int(m) + a
	}

Interface de bir tür olduğundan bir fonksiyona paslayabiliriz:

.play code/interfaces/interfaces.go /START OMIT/,/END OMIT/

* Interfaces (Standart kitaplıktan örnekler)

Bir türün ayıklanabilir kılmak

	type Sorter interface {
		Len() int
		Less(i, j int) bool
		Swap(i, j int)
	}

fmt.Printf() cıktısını kontrol etmek

	type Stringer interface {
		String() string
	}

Herhangi bir türe HTTP serve desteği vermek

	type Handler interface {
		ServeHTTP(ResponseWriter, *Request)
	}

* Interfaces (Stringer örneği)

Point ve MyInt türlerine *Stringer* desteği verelim

	func (p Point) String() string {
		return fmt.Sprintf("X: %d Y: %d Sum: %d", p.X, p.Y, p.Add(0))
	}

	func (m MyInt) String() string {
		return "*** " + strconv.Itoa(int(m)) + " ***"
	}


.play code/interfaces2/interfaces2.go /START OMIT/,/END OMIT/

* Interfaces (Çevreleme)

Girdi ve çıktısi interface olan fonksiyonlar hem bağımsız hem de ölçeklenebilir
bir yazılım yapmanıza olanak sağlar:

	func LoggingReader(r io.Reader) io.Reader
	func LimitingReader(r io.Reader, n int64) io.Reader
	func ErrorInjector(r io.Reader) io.Reader

* Interfaces (Çevreleme örnek)

Color paketi (https://github.com/fatih/color) sadece Linux/Mac OS X benzeri
işletim sistemlerinde calışıyordu (ANSI desteği olanlarda)

Renk çıktısını kontrol eden değişken bir Interface türu (io.Writer). Mevcut
standard output'u kullaniyor.

	var Output io.Writer = os.Stdout

Windows ANSI desteklemiyor. Çözum:

.image color.png

* Goroutine

Goroutine eş zamanlı olarak başka fonksiyonlar ile çalışabilen fonksiyonlara
denilir.

Go'da her fonksiyon başka bir goroutine tarafından çağırılır ve çalıştırılır.

Main fonksiyon'u ilk *goroutine* olarak başlangıç adımını yapar.

*go* kelimesi ile yeni bir goroutine başlatılır

	go f(x, y, z)

* Goroutine (devam)

Öntanımlı olarak her fonksiyon çağrı **blocking*

.play -edit code/goroutine/goroutine.go /START OMIT/,/END OMIT/

* Channels
* Range
* Select

* Araçlar
* Go tool
* Godoc
* Gofmt
* Test (yazmak)
* Test (çalıstırmak)
* Test (ölçmek)


* Go araçlari (go get, gofmt, go test, golint, vs...)
* Koding'de Go nasil kullanılıyor? Deploy nasıl yapılır?
* Editör desteği ve uyumluluğu
* Go camiasi (go-nuts, irc, go-türkiye ...)
* Go ne degildir ve ne icin kullanilmaz
* Nasil Go ogrenemeye baslayabilirim?
* Go nasil kurulur?
* Kaynaklar, kitaplar, öğrenilmesi gerekenler ...
* Soru/Cevap

